// ignore_for_file: must_be_immutable, non_constant_identifier_names

part of 'binder.dart';

Checkbox CheckboxB(
  Binder<bool?> binder, {
  Key? key,
  bool tristate = false,
  MouseCursor? mouseCursor,
  Color? activeColor,
  WidgetStateProperty<Color?>? fillColor,
  Color? checkColor,
  Color? focusColor,
  Color? hoverColor,
  WidgetStateProperty<Color?>? overlayColor,
  double? splashRadius,
  MaterialTapTargetSize? materialTapTargetSize,
  VisualDensity? visualDensity,
  FocusNode? focusNode,
  bool autofocus = false,
  OutlinedBorder? shape,
  BorderSide? side,
  bool isError = false,
  String? semanticLabel,
}) {
  return Checkbox(
    value: binder.value,
    onChanged: (b) {
      binder.value = b;
      binder.fireUpdateUI();
      binder.fireChanged();
    },
    key: key,
    tristate: tristate,
    mouseCursor: mouseCursor,
    activeColor: activeColor,
    fillColor: fillColor,
    checkColor: checkColor,
    focusColor: focusColor,
    hoverColor: hoverColor,
    overlayColor: overlayColor,
    splashRadius: splashRadius,
    materialTapTargetSize: materialTapTargetSize,
    visualDensity: visualDensity,
    focusNode: focusNode,
    autofocus: autofocus,
    shape: shape,
    side: side,
    isError: isError,
    semanticLabel: semanticLabel,
  );
}

Switch SwitchB(Binder<bool> binder,
    {Color? activeColor,
    Color? activeTrackColor,
    Color? inactiveThumbColor,
    Color? inactiveTrackColor,
    ImageProvider<Object>? activeThumbImage,
    void Function(Object, StackTrace?)? onActiveThumbImageError,
    ImageProvider<Object>? inactiveThumbImage,
    void Function(Object, StackTrace?)? onInactiveThumbImageError,
    WidgetStateProperty<Color?>? thumbColor,
    WidgetStateProperty<Color?>? trackColor,
    WidgetStateProperty<Color?>? trackOutlineColor,
    WidgetStateProperty<double?>? trackOutlineWidth,
    WidgetStateProperty<Icon?>? thumbIcon,
    MaterialTapTargetSize? materialTapTargetSize,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    MouseCursor? mouseCursor,
    Color? focusColor,
    Color? hoverColor,
    WidgetStateProperty<Color?>? overlayColor,
    double? splashRadius,
    FocusNode? focusNode,
    void Function(bool)? onFocusChange,
    bool autofocus = false}) {
  return Switch(
      value: binder.value,
      onChanged: (b) {
        binder.value = b;
        binder.fireUpdateUI();
        binder.fireChanged();
      },
      activeColor: activeColor,
      activeTrackColor: activeTrackColor,
      inactiveThumbColor: inactiveThumbColor,
      inactiveTrackColor: inactiveTrackColor,
      activeThumbImage: activeThumbImage,
      onActiveThumbImageError: onActiveThumbImageError,
      inactiveThumbImage: inactiveThumbImage,
      onInactiveThumbImageError: onInactiveThumbImageError,
      thumbColor: thumbColor,
      trackColor: trackColor,
      trackOutlineColor: trackOutlineColor,
      trackOutlineWidth: trackOutlineWidth,
      thumbIcon: thumbIcon,
      materialTapTargetSize: materialTapTargetSize,
      dragStartBehavior: dragStartBehavior,
      mouseCursor: mouseCursor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      overlayColor: overlayColor,
      splashRadius: splashRadius,
      focusNode: focusNode,
      onFocusChange: onFocusChange,
      autofocus: autofocus);
}

TextField TextFieldB(
  Binder<String> binder, {
  TextEditingController? controller,
  FocusNode? focusNode,
  UndoHistoryController? undoController,
  InputDecoration? decoration = const InputDecoration(),
  TextInputType? keyboardType,
  TextInputAction? textInputAction,
  TextCapitalization textCapitalization = TextCapitalization.none,
  TextStyle? style,
  StrutStyle? strutStyle,
  TextAlign textAlign = TextAlign.start,
  TextAlignVertical? textAlignVertical,
  TextDirection? textDirection,
  bool readOnly = false,
  bool? showCursor,
  bool autofocus = false,
  String obscuringCharacter = 'â€¢',
  bool obscureText = false,
  bool autocorrect = true,
  SmartDashesType? smartDashesType,
  SmartQuotesType? smartQuotesType,
  bool enableSuggestions = true,
  int? maxLines = 1,
  int? minLines,
  bool expands = false,
  int? maxLength,
  MaxLengthEnforcement? maxLengthEnforcement,
  void Function(String)? onChanged,
  void Function()? onEditingComplete,
  void Function(String)? onSubmitted,
  void Function(String, Map<String, dynamic>)? onAppPrivateCommand,
  List<TextInputFormatter>? inputFormatters,
  bool? enabled,
  double cursorWidth = 2.0,
  double? cursorHeight,
  Radius? cursorRadius,
  bool? cursorOpacityAnimates,
  Color? cursorColor,
  BoxHeightStyle selectionHeightStyle = BoxHeightStyle.tight,
  BoxWidthStyle selectionWidthStyle = BoxWidthStyle.tight,
  Brightness? keyboardAppearance,
  EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
  DragStartBehavior dragStartBehavior = DragStartBehavior.start,
  bool? enableInteractiveSelection,
  TextSelectionControls? selectionControls,
  void Function()? onTap,
  void Function(PointerDownEvent)? onTapOutside,
  MouseCursor? mouseCursor,
  Widget? Function(BuildContext, {required int currentLength, required bool isFocused, required int? maxLength})? buildCounter,
  ScrollController? scrollController,
  ScrollPhysics? scrollPhysics,
  Iterable<String>? autofillHints = const <String>[],
  ContentInsertionConfiguration? contentInsertionConfiguration,
  Clip clipBehavior = Clip.hardEdge,
  String? restorationId,
  bool scribbleEnabled = true,
  bool enableIMEPersonalizedLearning = true,
  Widget Function(BuildContext, EditableTextState)? contextMenuBuilder = _defaultContextMenuBuilder,
  bool canRequestFocus = true,
  SpellCheckConfiguration? spellCheckConfiguration,
  TextMagnifierConfiguration? magnifierConfiguration,
}) {
  late TextEditingController con;
  if (controller != null) {
    controller.text = binder.value;
    con = controller;
  } else {
    con = TextEditingController(text: binder.value);
  }

  return TextField(
    controller: con,
    onChanged: (s) {
      binder.value = s;
      binder.fireChanged();
    },
    focusNode: focusNode,
    undoController: undoController,
    decoration: decoration,
    keyboardType: keyboardType,
    textInputAction: textInputAction,
    textCapitalization: textCapitalization,
    style: style,
    strutStyle: strutStyle,
    textAlign: textAlign,
    textAlignVertical: textAlignVertical,
    textDirection: textDirection,
    readOnly: readOnly,
    showCursor: showCursor,
    autofocus: autofocus,
    obscuringCharacter: obscuringCharacter,
    obscureText: obscureText,
    autocorrect: autocorrect,
    smartDashesType: smartDashesType,
    smartQuotesType: smartQuotesType,
    enableSuggestions: enableSuggestions,
    maxLines: maxLines,
    minLines: minLines,
    expands: expands,
    maxLength: maxLength,
    maxLengthEnforcement: maxLengthEnforcement,
    onEditingComplete: onEditingComplete,
    onSubmitted: onSubmitted,
    onAppPrivateCommand: onAppPrivateCommand,
    inputFormatters: inputFormatters,
    enabled: enabled,
    cursorWidth: cursorWidth,
    selectionHeightStyle: selectionHeightStyle,
    selectionWidthStyle: selectionWidthStyle,
    keyboardAppearance: keyboardAppearance,
    scrollPadding: scrollPadding,
    dragStartBehavior: dragStartBehavior,
    enableInteractiveSelection: enableInteractiveSelection,
    selectionControls: selectionControls,
    onTap: onTap,
    onTapOutside: onTapOutside,
    mouseCursor: mouseCursor,
    buildCounter: buildCounter,
    scrollController: scrollController,
    scrollPhysics: scrollPhysics,
    autofillHints: autofillHints,
    contentInsertionConfiguration: contentInsertionConfiguration,
    clipBehavior: clipBehavior,
    restorationId: restorationId,
    scribbleEnabled: scribbleEnabled,
    enableIMEPersonalizedLearning: enableIMEPersonalizedLearning,
    contextMenuBuilder: contextMenuBuilder,
    canRequestFocus: canRequestFocus,
    spellCheckConfiguration: spellCheckConfiguration,
    magnifierConfiguration: magnifierConfiguration,
  );
}

Widget _defaultContextMenuBuilder(BuildContext context, EditableTextState editableTextState) {
  return AdaptiveTextSelectionToolbar.editableText(
    editableTextState: editableTextState,
  );
}
